# Copyright (c) 2025 ETH Zurich.
#                    All rights reserved.
#
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
#
# Game Variant Generator - Converts regulator responses into playable game structures

import sys
import os

# Independent project - use local dependencies
current_dir = os.path.dirname(os.path.abspath(__file__))
dependencies_dir = os.path.join(current_dir, 'dependencies')
sys.path.insert(0, dependencies_dir)

from games_structures.base_game import BaseGameStructure
from langchain_core.messages import HumanMessage
from pydantic import BaseModel
from typing import Literal, Type
from regulator_agent import GameVariantResponse


class VariantGameStructure(BaseGameStructure):
    """
    A game structure that wraps a variant generated by the regulator agent.
    This allows us to use the variant in the existing game framework.
    """
    
    def __init__(self, base_game: BaseGameStructure, variant: GameVariantResponse):
        """
        Initialize a variant game structure.
        
        Args:
            base_game (BaseGameStructure): The original base game
            variant (GameVariantResponse): The generated variant
        """
        import json
        self._base_game = base_game
        self._variant = variant
        self._variant_description = variant.variant_description
        
        # Parse payoff matrix from JSON string and convert string keys to tuples
        try:
            if isinstance(variant.variant_payoff_matrix, str):
                variant_payoff_raw = json.loads(variant.variant_payoff_matrix)
            else:
                variant_payoff_raw = variant.variant_payoff_matrix
            
            # Convert string keys like "cooperate,defect" to tuples ("cooperate", "defect")
            self._variant_payoff = {}
            for key, value in variant_payoff_raw.items():
                if isinstance(key, str) and ',' in key:
                    # Parse "cooperate,defect" -> ("cooperate", "defect")
                    parts = [p.strip() for p in key.split(',')]
                    if len(parts) == 2:
                        tuple_key = (parts[0], parts[1])
                    else:
                        tuple_key = key  # Fallback to original key
                elif isinstance(key, tuple):
                    tuple_key = key
                else:
                    tuple_key = key  # Keep as is
                
                # Ensure value is a tuple of two integers
                if isinstance(value, list) and len(value) == 2:
                    self._variant_payoff[tuple_key] = (int(value[0]), int(value[1]))
                elif isinstance(value, tuple) and len(value) == 2:
                    self._variant_payoff[tuple_key] = (int(value[0]), int(value[1]))
                else:
                    self._variant_payoff[tuple_key] = value
                    
        except (json.JSONDecodeError, TypeError, ValueError) as e:
            # Fallback to base game payoff if parsing fails
            print(f"Warning: Failed to parse variant payoff matrix: {e}")
            print("Falling back to base game payoff matrix.")
            self._variant_payoff = None
    
    @property
    def game_name(self) -> str:
        return f"{self._base_game.game_name}_variant"
    
    @property
    def ActionResponse(self) -> Type[BaseModel]:
        """Use the same action response as the base game."""
        return self._base_game.ActionResponse
    
    @property
    def GAME_PROMPT(self) -> HumanMessage:
        """Return the variant description as the game prompt."""
        return HumanMessage(self._variant_description)
    
    @property
    def payoff_matrix(self) -> dict:
        """Return the variant payoff matrix, or base if not provided."""
        if self._variant_payoff:
            # _variant_payoff is already parsed dict from __init__
            return self._variant_payoff
        return self._base_game.payoff_matrix
    
    @property
    def complexity_level(self) -> str:
        """Return the complexity level of the variant."""
        return self._variant.complexity_level
    
    @property
    def reasoning(self) -> str:
        """Return the reasoning for why this variant was created."""
        return self._variant.reasoning


class GameVariantGenerator:
    """
    Generator that creates playable game variants from regulator responses.
    """
    
    @staticmethod
    def create_variant_game(
        base_game: BaseGameStructure,
        variant: GameVariantResponse
    ) -> VariantGameStructure:
        """
        Create a playable variant game structure.
        
        Args:
            base_game (BaseGameStructure): The base game
            variant (GameVariantResponse): The variant response
        
        Returns:
            VariantGameStructure: A playable game structure
        """
        return VariantGameStructure(base_game, variant)
    
    @staticmethod
    def validate_variant(
        base_game: BaseGameStructure,
        variant: GameVariantResponse
    ) -> tuple[bool, str]:
        """
        Validate that a variant is compatible with the base game.
        
        Args:
            base_game (BaseGameStructure): The base game
            variant (GameVariantResponse): The variant to validate
        
        Returns:
            tuple[bool, str]: (is_valid, error_message)
        """
        # Check that action space is compatible
        base_action_response = base_game.ActionResponse
        base_action_type = base_action_response.__annotations__["action"]
        
        # Check payoff matrix format
        if variant.variant_payoff_matrix:
            import json
            # Validate payoff matrix has correct structure
            base_payoff = base_game.payoff_matrix
            
            # Parse variant payoff from JSON string
            try:
                if isinstance(variant.variant_payoff_matrix, str):
                    variant_payoff_raw = json.loads(variant.variant_payoff_matrix)
                else:
                    variant_payoff_raw = variant.variant_payoff_matrix
            except (json.JSONDecodeError, TypeError) as e:
                return False, f"Invalid JSON format in variant_payoff_matrix: {e}"
            
            # Convert string keys to tuples for comparison
            variant_payoff = {}
            for key, value in variant_payoff_raw.items():
                if isinstance(key, str) and ',' in key:
                    # Parse "cooperate,defect" -> ("cooperate", "defect")
                    parts = [p.strip() for p in key.split(',')]
                    if len(parts) == 2:
                        variant_payoff[(parts[0], parts[1])] = tuple(value) if isinstance(value, list) else value
                    else:
                        variant_payoff[key] = tuple(value) if isinstance(value, list) else value
                else:
                    variant_payoff[key] = tuple(value) if isinstance(value, list) else value
            
            # Check that all keys in variant payoff match base game structure
            base_keys = set(base_payoff.keys())
            variant_keys = set(variant_payoff.keys())
            missing_keys = base_keys - variant_keys
            if missing_keys:
                return False, f"Missing payoff for action combinations: {missing_keys}"
        
        return True, ""
